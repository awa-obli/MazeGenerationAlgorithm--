<h1 style="text-align: center;">迷宫生成算法</h1>
<div style="text-align: right;"><b>by awa</b></div>

> 本文档为对迷宫生成算法的描述（[generate_maze.py](generate_maze.py)）

> 由于本人菜得一匹，只能用print实现初步可视化，代码可能有很多瑕疵，请多多指教~>_<
> 
> 同时这也是我的第一个Github托管项目
> 
> 代码初始版本完成于2024/07/25

> 网络上大多只有迷宫寻路算法的介绍，但对于迷宫生成算法的介绍却寥寥无几
> 
> 于是我通过参考为数不多的资料，写下这个具有挑战性的项目。
> 
> 希望对你有所帮助！

**迷宫生成算法*3：**
1. [prim(最小生成树)](#一-prim最小生成树)；
2. [dfs(深度优先搜索)](#二-dfs深度优先搜索)；
3. [recursion(递归)](#三-recursion递归)

---

## 一. prim(最小生成树)：

> **函数名**：generate_maze_prim  
> **参数**：size  
> **重要变量**：
> 1. candidate_seq：候选序列(字典：键：候选对象位置（元组）；值：候选对象被打通的方向（匿名函数）)
> 2. visited：用于记录已访问格点的集合

### 1. 思路：

**随机获取候选者并打破，对于连接格点的相邻内部墙壁添加至候选序列，直到没有候选者，此时所有墙壁均已被打通。**

### 2. 流程：

1. 初始化一个迷宫：外围为**不可打破墙壁**（记为2），内部任意一个行或列为2的倍数的格点均为**边**（或称**墙壁**，记为1），其余为**空地**（记为0），使得所有空地外围（即4个边）均有墙壁。
2. 选择一个方格作为起始点。
3. 将该方格所有邻边添加到候选序列。
4. 从候选序列中随机访问一个候选者（墙）。
5. 调用该候选者对应的匿名函数，找到连接格点（空地）。
    - 如果候选者可以打通（连接格点未访问，即不在集合中）：
        1. 打通墙壁；
        2. 记录连接格点；
        3. 将连接格点的所有相邻内部墙壁添加至候选序列。
    - 如果候选者不可以打通（连接格点已访问，即在集合中）：
        1. 从候选序列中移除这个候选者。
6. 重复步骤4到5，直到所有的格点都被访问过（候选序列为空）。

---

## 二. dfs(深度优先搜索)：

> **函数名**：generate_maze_dfs  
> **参数**：size  
> **重要变量**：
> 1. stack：记录目前进入的格点的栈，用于判断是否访问了所有格点
> 2. visited：用于记录已访问格点的集合

### 1. 思路：

**从起点开始随机走，走不通了就返回上一步，从下一个能走的地方再开始随机走，直到走完。**

### 2. 流程：

1. 初始化一个迷宫：外围为**不可打破墙壁**（记为2），内部任意一个行或列为2的倍数的格点均为**边**（或称**墙壁**，记为1），其余为**空地**（记为0），使得所有空地外围（即4个边）均有墙壁。
2. 选择一个方格作为起始点。
3. 将该点压入栈中，并记录至集合中。
4. 获取当前格点。
5. 打乱访问方向（dirs）。
6. for循环访问：获取该访问方向对应的墙及其后连接的格点  
    - 如果是内部墙壁（即值为1）且连接格点未访问（即不在集合中）：  
        1. 打通墙壁；
        2. 进入下一格点（即连接格点），入栈；
        3. 记录该格点至集合中；
        4. 结束循环。
7. 若没有进入任何格点（即for循环正常退出）：  
    出栈
8. 重复步骤4到7，直到所有的格点都被访问过（栈空）。

---

## 三. recursion(递归)：

> **函数名**：generate_maze_partition(recursion_partition)  
> **参数**：
> 1. generate_maze_partition：size
> 2. recursion_partition：
>    1. maze：迷宫本体
>    2. row_start、row_end：当前子空间的行范围
>    3. col_start、col_end：当前子空间的列范围
> 
> **重要变量**：
> 1. partition_row、partition_col：十字分割的行与列
> 2. walls_to_be_chose：待选择的墙壁列表（先从十字墙壁的四个方向各随机选出一个墙壁，为后续随机三个墙壁打通做准备）
> 3. wall_to_be_connected：临时存储每一面被选中要被打通的墙

### 1. 思路：

**把空间用十字（横纵为偶）分成四个子空间，然后在三面墙（横纵为奇）上挖洞（确保连通四个子空间），之后对每个子空间继续做这件事直到空间不足以继续分割为止。**

### 2. 流程：

1. 初始化一个迷宫：外围为不可打破墙壁（记为2），内部均默认为空地（记为0）。
2. 调用递归函数：（以下为递归函数流程）
    1. 终止条件：
        检查子空间大小，若行范围、列范围任意一个不足3个格点（子空间行列范围界限均为奇数，所以空间不足即start==end时），子空间就视为不足（无法继续构建子空间），返回。
    2. 确定分割位置（偶数）
    3. 按照分割位置建造十字墙壁
    4. 随机打通三面墙
    5. 递归*4：对四个子空间递归分割
3. 返回

---

**完结撒花🎊**
